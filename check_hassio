#!/usr/bin/env python3
#
# Home Assistant sensor plugin for Nagios/Icinga
#
# (c) Gerrit Beine, 2019
#

import argparse
import requests
import json
import time
import sys
import re

status = 0
message = ''
args = {}

nagios_codes = [ 'OK', 'WARNING', 'CRITICAL', 'UNKNOWN' ]

parser = argparse.ArgumentParser()
parser.add_argument('-H', '--host', metavar="<hostname>", help="host to connect to (defaults to localhost)", dest='host', default="localhost")
parser.add_argument('-P', '--port', metavar="<port>", help="network port to connect to (defaults to 8123)", dest='port', default=8123, type=int)
parser.add_argument('-t', '--token', metavar="<token>", help="API token (defaults to None)", dest='token', default=None)
parser.add_argument('-s', '--sensor', metavar="<sensor>", help="Sensor id (default to None)", dest='sensor', default=None)
parser.add_argument('-S', '--ssl', help="use HTTPS", dest='ssl', default=False, action='store_true')
parser.add_argument('-I', '--int', help="Use state as int", dest='int', default=False, action='store_true')
parser.add_argument('-F', '--float', help="Use state as float", dest='float', default=False, action='store_true')
parser.add_argument('-T', '--timestamp', help="Use state as timestamp", dest='timestamp', default=False, action='store_true')
parser.add_argument('-e', '--expected', help="Check expected state (default to None). Case-insensitive regular expressions can be used", dest='expected', default=None, type=str)
parser.add_argument('-n', '--notexpected', help="Check not expected state (default to None). Case-insensitive regular expressions can be used", dest='notexpected', default=None, type=str)
parser.add_argument('-w', '--warning', help="Check if above threshold (warning, default to None)", dest='warning', default=None, type=float)
parser.add_argument('-c', '--critical', help="Check if above threshold (critical, default to None)", dest='critical', default=None, type=float)
parser.add_argument('-W', '--warning-below', help="Check if below threshold (warning, default to None)", dest='bwarning', default=None, type=float)
parser.add_argument('-C', '--critical-below', help="Check if below threshold (critical, default to None)", dest='bcritical', default=None, type=float)
parser.add_argument('-r', '--range', help="Check if in range [from:to] (default to None)", dest='range', default=None)
parser.add_argument('-j', '--json', help="output JSON", dest='json', default=False, action='store_true')

args = parser.parse_args()

if (args.warning and args.bwarning) or (args.critical and args.bcritical):
    print("Please specify only values for checking above or below thresholds.")
    sys.exit(3)
if args.warning and not args.critical:
    print("Checking for threshold requires values for --warning and --cricital.")
    sys.exit(3)
if not args.warning and args.critical:
    print("Checking for threshold requires values for --warning and --cricital.")
    sys.exit(3)
if args.bwarning and not args.bcritical:
    print("Checking for threshold requires values for --warning-below and --cricital-below.")
    sys.exit(3)
if not args.bwarning and args.bcritical:
    print("Checking for threshold requires values for --warning-below and --cricital-below.")
    sys.exit(3)
if args.range:
    borders = args.range.split(":")
    if len(borders) != 2:
        print("Checking for a range requires two numbers, e.g. '10:23'")
        sys.exit(3)
    args.range_upper = float(borders[1])
    args.range_lower = float(borders[0])

if args.ssl:
    url = "https"
else:
    url = "http"

url += "://" + args.host + ":" + str(args.port) + "/api/"

if args.sensor:
    url += "states/" + args.sensor

headers = {
    "Authorization": "Bearer " + args.token,
}

response = requests.request("GET", url, headers=headers)

data = json.loads(response.text)

if args.int or args.float:
    if args.int:
        state = int(data['state'])
    elif args.float:
        state = float(data['state'])

    # test if value is above thresholds
    if args.warning and args.warning > state:
        status = 0
        message = "State is {}".format(data['state'])
    elif args.critical and args.critical > state:
        status = 1
        message = "State {} is above {}".format(data['state'], args.warning)
    elif args.critical and args.critical <= state:
        status = 2
        message = "State {} is above {}".format(data['state'], args.critical)

    # test if value is below thresholds
    elif args.bwarning and args.bwarning < state:
        status = 0
        message = "State is {}".format(data['state'])
    elif args.bcritical and args.bcritical < state:
        status = 1
        message = "State {} is below {}".format(data['state'], args.bwarning)
    elif args.bcritical and args.bcritical >= state:
        status = 2
        message = "State {} is below {}".format(data['state'], args.bcritical)

    # test if value is in range
    elif args.range:
        if args.range_lower <= state <= args.range_upper:
            status = 0
            message = "State is {}".format(data['state'])
        else:
            status = 2
            message = "State {} is out of range {}".format(data['state'], args.range)

    else:
        status = 3
        message = "No thresholds or range defined fo state {}".format(data['state'])

elif args.timestamp:
    time = int(time.time())
    if args.expected is None:
        interval = 20
    else:
        interval = int(args.expected)
    if int(data['state']) > time - interval:
        status = 0
        message = "Timestamp is {}".format(data['state'])
    else:
        status = 2
        message = "Timestamp is {}, expected {} {}".format(data['state'], time, interval)

elif args.notexpected:
    # compile the regular expression pattern
    notexpected_pattern = re.compile(args.notexpected, re.IGNORECASE)
    # check to see if the notexpected_pattern matches the state
    if re.match(notexpected_pattern, data['state']):
        status = 2
        # hide any | from Nagios since that has a special meaning for it
        escaped_arg = args.notexpected.replace('|', r':')
        message = "State is {}, not expected {}".format(data['state'], escaped_arg)
    else:
        status = 0
        message = "State is {}".format(data['state'])

else:
    # compile the regular expression pattern
    expected_pattern = re.compile(args.expected, re.IGNORECASE)
    # check to see if the expected_pattern matches the state
    if expected_pattern.search(data['state']):
        status = 0
        message = "State is {}".format(data['state'])
    else:
        status = 2
        # hide any | from Nagios since that has a special meaning for it
        escaped_arg = args.expected.replace('|', r':')
        message = "State is {}, expected {}".format(data['state'], escaped_arg)

print("{} - {}".format(nagios_codes[status], message))

if args.json:
   print(data)

sys.exit(status)

